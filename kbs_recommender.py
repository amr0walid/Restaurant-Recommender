# -*- coding: utf-8 -*-
"""KBS_recommender

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kpw6Pu1ShC0KRvvPlbYcdGsOQeT3zLvz
"""

import pandas as pd
import numpy as np
from ast import literal_eval

import pandas as pd
import streamlit as st

def preprocess_restaurant_data(data_file):
    rest = pd.read_csv(data_file)
    rest['RestID'] = rest.index + 1
    rest.rename_axis('ID_Old', inplace=True)
    rest.rename(columns={'Cuisine Style': 'Cuisine', 'Number of Reviews': 'Count', 'Price Range': 'Price'}, inplace=True)
    rest.drop(columns=['ID_TA', 'Ranking', 'City'], inplace=True, errors='ignore')
    rest['Rating'].fillna(rest['Rating'].mean(), inplace=True)
    price_map = {'$': 20, '$$ - $$$': 50, '$$$$': 100}
    rest['Price'] = rest['Price'].map(price_map)
    rest['Reviews'] = rest['Reviews'].apply(lambda x: x.split('],')[0].replace('[','').replace("'", "") if isinstance(x, str) else '')
    rest.reset_index(drop=True, inplace=True)
    rest.drop(columns=['ID_Old'], inplace=True, errors='ignore')
    return rest

def get_restaurants_by_cuisine(rest_df, cuisine):
    restaurants = rest_df.dropna(subset=['Cuisine'])  # Drop rows with NaN values in 'Cuisine' column
    restaurants = restaurants[restaurants['Cuisine'].str.lower().str.contains(cuisine.lower())]
    return restaurants


def get_statistics(rest_df):
    stats = {
        'Total Restaurants': len(rest_df),
        'Average Rating': rest_df['Rating'].mean(),
        'Most Common Cuisine': rest_df['Cuisine'].mode().values[0]
    }
    return stats


def build_restaurant_chart(cuisine,min_reviews , max_price_symbol, min_price_symbol , rest_df, percentile=0.8):

    # Map user input symbols to corresponding price values
    price_map = {'$': 20, '$$ - $$$': 50, '$$$$': 100}
    min_price = price_map.get(min_price_symbol, None)
    max_price = price_map.get(max_price_symbol, None)

    if min_price is None or max_price is None:
        print("Invalid price range input.")
        return None

    restaurants = rest_df.copy()
    restaurants = restaurants[(restaurants['Count'] >= min_reviews) &
                              (restaurants['Price'] >= min_price) &
                              (restaurants['Price'] <= max_price)]
    
    filtered_resturants = get_restaurants_by_cuisine(restaurants, cuisine).head()

    C = filtered_resturants['Rating'].mean()
    m = filtered_resturants['Count'].quantile(percentile)
    popular_restaurants = filtered_resturants.copy().loc[restaurants['Count'] >= m]
    popular_restaurants['score'] = popular_restaurants.apply(lambda x: (x['Count'] / (x['Count'] + m) * x['Rating']) + (m / (m + x['Count']) * C), axis=1)
    popular_restaurants = popular_restaurants.sort_values('score', ascending=False)

    return popular_restaurants



# Usage
data_file = 'Europe_Restaurants.csv'
rest_df = preprocess_restaurant_data(data_file)
# print(get_statistics(rest_df))
# print(get_restaurants_by_cuisine(rest_df, 'Italian').head())
# print(build_restaurant_chart(rest_df))

st.markdown("# hybrid Recommender systems")

with st.form(key='my_form'):
    
    st.text_input(label='enter cuisine type:',key= 'cuisine')
    st.text_input(label='enter min reviws:',key= 'min_reviews')
    st.text_input(label='Input maximum price range ($, $$ - $$$, $$$$):',key= 'max_price')
    st.text_input(label='Input minimum price range ($, $$ - $$$, $$$$):',key= 'min_price')
    
    

    submit = st.form_submit_button(label='recommend')

    if submit :
        rrecommendations = build_restaurant_chart(st.session_state.cuisine,int(st.session_state.min_reviews),st.session_state.max_price, st.session_state.min_price,rest_df)
        st.write(get_statistics(rest_df))
        st.write(get_restaurants_by_cuisine(rest_df,st.session_state.cuisine).head())
        st.table(rrecommendations)

